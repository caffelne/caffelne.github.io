<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【Heap.01】堆利用学习笔记 | uuu</title><meta name="keywords" content="堆"><meta name="author" content="uuu"><meta name="copyright" content="uuu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Be brave. The world is our oyster.">
<meta property="og:type" content="article">
<meta property="og:title" content="【Heap.01】堆利用学习笔记">
<meta property="og:url" content="http://caffelne.github.io/posts/53983.html">
<meta property="og:site_name" content="uuu">
<meta property="og:description" content="Be brave. The world is our oyster.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/pwn_1@Lifeline.jpg">
<meta property="article:published_time" content="2022-03-05T13:47:48.000Z">
<meta property="article:modified_time" content="2022-05-24T08:45:59.999Z">
<meta property="article:author" content="uuu">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/pwn_1@Lifeline.jpg"><link rel="shortcut icon" href="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/uuu.jpg"><link rel="canonical" href="http://caffelne.github.io/posts/53983"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Heap.01】堆利用学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-24 16:45:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/caffe1ne.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/pwn_1@Lifeline.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">uuu</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Heap.01】堆利用学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-05T13:47:48.000Z" title="发表于 2022-03-05 21:47:48">2022-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-24T08:45:59.999Z" title="更新于 2022-05-24 16:45:59">2022-05-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/Pwn/">Pwn</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/Pwn/%E5%A0%86/">堆</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Heap.01】堆利用学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>知其然，知其所以然。</p>
</blockquote>	
<p>​	Pwn 的入门对我来说属实艰难，一路跟着各位二进制 <span class="emoji" alias="older_man" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f474.png?v8">👴</span> 的博客文章学习学到了好多好东西。这里做点零碎的学习记录，如发现错误，还请各位 <span class="emoji" alias="older_man" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f474.png?v8">👴</span> 不吝赐教。</p>
<p>​	事实证明这玩意不是我以为我会了就会了<span class="emoji" alias="anger" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a2.png?v8">💢</span>，不带脑子地看源码把自己看飘了，每种 attack 都要进行相关练习。</p>
<p>​	<em><strong>2022/5/9</strong></em>: <span class="emoji" alias="dove" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f54a.png?v8">🕊</span> 这里写的东西并不全，只能说是记录下刚学的时候碰到的东西。这玩意我觉得我是写不完的，只能说写点是点吧。</p>
<h1>Attack</h1>
<h2 id="Off-by-one">Off by one</h2>
<p><strong>Off by one</strong>，顾名思义，就是溢出一个字节。当溢出字节为关键位置的时候，可以进行一波程序的 <span class="emoji" alias="sheep" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f411.png?v8">🐑</span> 。</p>
<h3 id="利用思路">利用思路</h3>
<ol>
<li>打堆重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法(<strong>Off by NULL</strong>)</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 打 unlink 。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，打堆重叠。unlink 方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ol>
<h3 id="常见漏洞">常见漏洞</h3>
<ol>
<li>循环次数不合理</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gets</span><span class="params">(<span class="keyword">char</span> *ptr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input:&quot;</span>);</span><br><span class="line">    my_gets(chunk1,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <strong>i&lt;=size</strong> 的错误写法，使得实际读入的数据会比 size 多一位。</p>
<ol start="2">
<li>函数行为不一致</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <strong>strlen()</strong> 函数计算字符串长度不把 <strong>\x00</strong> 计算在内，但是 <strong>strcpy()</strong> 在复制字符串的时候会拷贝 <strong>\x00</strong> ，造成 <strong>Off by NULL</strong> 漏洞。</p>
<h3 id="相关题目记录">相关题目记录</h3>
<p>Off by one:</p>
<p><a target="_blank" rel="noopener" href="https://caffeine.darkflow.top/posts/21b97b6b.html#%E5%90%83%E9%B8%A1%E6%9D%AF-ezheap">CTFshow - ezheap</a></p>
<hr>
<h2 id="Chunk-Extend-and-Overlapping">Chunk Extend and Overlapping</h2>
<p>堆块扩展与重叠</p>
<h3 id="注意-2">注意</h3>
<p>需要存在控制 chunk 头 size 的漏洞(如 <strong>off by one</strong>等)。</p>
<p><strong>Off by NULL</strong> 则一般考虑 <code>malloc(0xf8)</code>，这样覆盖掉 <code>0x101</code> 可以覆盖掉 prev_inuse 位。</p>
<p>在 <strong>libc 2.29</strong> 加入了相关的检查机制。</p>
<h3 id="效果">效果</h3>
<ol>
<li>拿一个更大的堆块不香吗</li>
<li>拿一个带有关键指针的堆块不香吗</li>
</ol>
<h3 id="原理-3">原理</h3>
<p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。而这些宏它们是<em><strong>以 chunk 头部的 size 位来确定前后堆块以及相关信息</strong></em>，这就产生了利用空间。</p>
<p>chunk overlap 是得到包含一个小 chunk 的大 chunk 的一种攻击手段，之后可以 free 掉小 chunk ，从而通过程序提供的相关功能，达到泄露(<strong>show</strong>)甚至修改(<strong>edit</strong>)相关指针的效果。</p>
<p>在 ptmalloc 中，获取 chunk 块大小的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>
<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p>
<p>在 ptmalloc 中，获取下一 chunk 块地址的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>
<p>即使用当前块指针加上当前块大小。</p>
<p>在 ptmalloc 中，获取前一个 chunk 信息的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>
<p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p>
<p>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<h3 id="利用示例-libc-2-23下-，libc-2-27-则先处理-Tcache">利用示例(libc 2.23下 ，libc 2.27 则先处理 Tcache)</h3>
<ol>
<li>向高地址进行操作</li>
</ol>
<p>相当好理解，比较容易掌握。**改大 chunk 的 size，free 后再拿出来就变大了。**注意绕一下 prev_inuse 的检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line">	<span class="comment">// 注意 ptr 指向的是 chunk 1 的 user 区域(不含 chunk 头)</span></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);	<span class="comment">//chunk 1	Chunk size:0x20</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);	<span class="comment">//chunk 2	Chunk size:0x20</span></span><br><span class="line">	<span class="comment">// 在寻找 chunk 1 的高地址 chunk 时会找到 chunk 1 头 + 0x40</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;	<span class="comment">// 修改第一个块的size域</span></span><br><span class="line">	<span class="comment">// 这里要保证 chunk 1 头 + 0x40 处的 chunk 的 prev_inuse 位为 1</span></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);	<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>向低地址进行操作</li>
</ol>
<p>当 free 一个不属于 fastbin 范围的 chunk 时，会先向低地址判断是否合并，之后向高地址判断是否合并。</p>
<p>这里实际原理比较复杂，分步解释下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//smallbin1	Chunk size:0x90</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1	Chunk size:0x20</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2	Chunk size:0x20</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//smallbin2	Chunk size:0x90</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="comment">//我们这里 free 掉了 smallbin1 ，smallbin1 会先进入到 unsorbin 里，形成双向链表，绕过 unlink 检查</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    <span class="comment">// 标记上个堆块处于 free 状态</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;		<span class="comment">//修改pre_inuse域	</span></span><br><span class="line">    <span class="comment">// 往低地址查找 chunk 时会找到 smallbin1</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;	<span class="comment">//修改pre_size域	0xd0 = 13 * 0x10 = 0x90 + 0x20 + 0x20</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);	<span class="comment">// 触发 unlink</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);	<span class="comment">// 取出合并后的块 Chunk size:0x150 = 22 * 0x10 = 0x90 + 0x20 + 0x20 + 0x90</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相关代码">相关代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">// p 为被 free 的 chunk，上面的例子里是 smallbin2</span></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       <span class="comment">// prevsize 为 chunk p 的 prev_size 位填写的数据，例子中我们把它扬成了 0</span></span><br><span class="line">     prevsize = prev_size (p);</span><br><span class="line">       <span class="comment">// size 增加对应的大小，后面 set 的时候要用到 size 定位</span></span><br><span class="line">     size += prevsize;</span><br><span class="line">       <span class="comment">// 通过 -prevsize 找到低地址的 chunk</span></span><br><span class="line">     p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">       <span class="comment">// 执行 unlink 操作</span></span><br><span class="line">     unlink(av, p, bck, fwd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高地址的下一个 chunk 不是 topchunk 的话，将它的 prev_inuse 位设为 0</span></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">     &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       <span class="comment">/* unsortedbin 入链操作*/</span></span><br><span class="line">       <span class="comment">// bck 是 unsortedbin 链表头</span></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">       <span class="comment">// fwd 是 unsorted 最近加入的 chunk</span></span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">       <span class="comment">// 链表为空则报错</span></span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">       <span class="comment">// p 变为最近加入的 chunk，fd 指向先前这个位置的 chunk，bk指向链表头</span></span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">       <span class="comment">// 如果不属于 smallbin 范围，还要把 size 相关指针置空</span></span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">// p 变为最近加入的 chunk，链表头的 fd 指向它</span></span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">       <span class="comment">// 原先的 chunk 现在变成 次 最近加入的 chunk 了，bk 指向最近加入的 chunk</span></span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line">       <span class="comment">// 设置 chunk p 的 size 和 prev_inuse 位</span></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">       <span class="comment">// 修改 chunk p 下一个 chunk 的 prev_size 位</span></span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>那么最后我们就能在 unsortedbin 中找到从 smallbin1头 一直到 smallbin2 末尾的超大 chunk ，就可以愉快的搞事情了。</p>
<h3 id="unlink-绕过原理">unlink 绕过原理</h3>
<p>其中，向低地址合并时 unlink 部分存在相关检测，具体在下面的 unlink 部分有写出（不过下面介绍的是另一种攻击方式）。这里主要看一下执行 unlink 的 chunk 属于 smallbin 范围时的相关检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 1.被 unlink 的 chunk 大小要和下一个 chunk 的 prev_size 相同</span></span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line">  <span class="comment">// 2.对 fd 和 bk 的检查</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure>
<p>在我们没有对 nextchunk 也就是高地址的 chunk 进行乱搞的情况下，检查 1 是不用想办法去绕过的。</p>
<p>而我们早早就把 smallbin1 丢入了 <strong>unsortedbin</strong> 里面，注意这时 unsortedbin 里面只有 smallbin 一个 chunk，那么 smallbin1 的 fd 和 bk 指针都是指向 unsortedbin 的链表头，链表头的 fd 和 bk又都是指向 smallbin1。 也就很巧妙地绕过了检查 2。</p>
<h3 id="libc-2-29-检测代码">libc 2.29 检测代码</h3>
<p>为方便继续沿用上面的例子说明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">// p 为 smallbin2</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">    <span class="comment">// 这里 p 取到了 smallbin1</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    <span class="comment">// smallbin1 的大小和我们构造的 prevsize 肯定是不一样的，毕竟我们要扩大控制的 chunk 大小，于是报错</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时我们原先的利用方法就失效了，便需要使用新的攻击方法。</p>
<p>待填坑</p>
<h3 id="参考资料">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://surager.pub/_posts/2020-05-24-%E5%85%B3%E4%BA%8Elibc2.29%E4%B8%AD%E7%9A%84off-by-null/">关于libc2.29中的off-by-null - surager</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-257901.htm">glibc2.29下的off-by-null - t1an5g</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.eonew.cn/2019-08-02.Glibc-2.29%20%E6%96%B0%E5%A2%9E%E7%9A%84%E9%98%B2%E6%8A%A4%E6%9C%BA%E5%88%B6.html">Glibc-2.29 新增的防护机制 - Ex</a></p>
<hr>
<h2 id="Unsortedbin-Attack-libc-2-28">Unsortedbin Attack(&lt; libc 2.28)</h2>
<p>how2heap上的描述是&lt;libc-2.29。但有师傅实测该补丁已经给到了glibc2.27-3ubuntu1.4</p>
<p>在介绍 Unsortedbin 攻击前，可以先回顾一下 Unsorted Bin 的基本来源以及基本使用情况。</p>
<h3 id="基本来源">基本来源</h3>
<ol>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li>
<li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li>
</ol>
<h3 id="基本使用情况">基本使用情况</h3>
<ol>
<li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找  chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li>
</ol>
<h3 id="作用">作用</h3>
<p>任意地址泄露 main_arena ，任意地址写入 main_arena 固定偏移地址(很大的数字)，为后续攻击做准备。</p>
<h3 id="相关代码-2">相关代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//victim 取最先进入 unsortedchunk 的 chunk</span></span><br><span class="line">      <span class="comment">//unsortedchunk 不为空则遍历</span></span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//这里我们提前布置好 victim-&gt;bk = target_addr - 0x10</span></span><br><span class="line">          bck = victim-&gt;bk;	</span><br><span class="line">          </span><br><span class="line"><span class="comment">//这一部分代码是检查和 remainder 相关内容 可以先跳到后一段 /**********************************************************************************************************/</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line"><span class="comment">//这里实现了Unsortedbin Attack</span></span><br><span class="line"><span class="comment">/**********************************************************************************************************/</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 那这里就会在 target_addr 的位置上写入 写入 main_arena 固定偏移地址 (很大的数字)</span></span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">          </span><br><span class="line"><span class="comment">//下面是拿出来的 bin 分配的相关代码，也可以先跳过</span></span><br><span class="line"><span class="comment">/**********************************************************************************************************/</span></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line">              </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line">            tcache_put (victim, tc_idx);</span><br><span class="line">            return_cached = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">          ......</span><br></pre></td></tr></table></figure>
<h3 id="关键代码">关键代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//这里我们提前布置好 victim-&gt;bk = target_addr - 0x10</span></span><br><span class="line">      bck = victim-&gt;bk;	</span><br><span class="line">   ...</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line"><span class="comment">// 那这里就会在 target_addr 的位置上写入 main_arena 固定偏移地址</span></span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<h3 id="检查代码">检查代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; CHUNK_HDR_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br><span class="line">...</span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>​	Unsortedbin Attack 有点 bug ，给堆利用提供了很大便利，于是就被这一段检查代码给 <span class="emoji" alias="hocho" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f52a.png?v8">🔪</span> 了。</p>
<p>​	上面的一段检查代码在 <strong>libc 2.28</strong>  前一般是没有的。</p>
<h3 id="参考资料-2">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/">Unsorted Bin Attack - CTF Wiki</a></p>
<hr>
<h2 id="Largebin-Attack">Largebin Attack</h2>
<p>​	Unsortedbin Attack 太好用了所以被检查代码 <span class="emoji" alias="sheep" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f411.png?v8">🐑</span> 了，好在 Largebin 可以实现类似的效果。</p>
<h3 id="相关代码-3">相关代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//victim 取最先进入 unsortedchunk 的 chunk</span></span><br><span class="line">      <span class="comment">//unsortedchunk 不为空则遍历</span></span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// bck 为 次 最先进入 unsortedbin 的 chunk</span></span><br><span class="line">          bck = victim-&gt;bk;	</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (chunksize_nomask (victim)</span><br><span class="line">				   &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): memory corruption&quot;</span>);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果所请求的 chunk 属于 smallbin 的范围</span></span><br><span class="line">          <span class="comment">// unsortedbin只有 victim 一个 chunk</span></span><br><span class="line">          <span class="comment">// victim 是 last_reminder ，分配请求的 chunk 后的大小依然大于 MINSIZE</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">// 切割 reminder 分配 chunk 并记录新的 reminder 信息</span></span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 设置 victim 和 reminder chunk 相关信息</span></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              <span class="comment">// 设置 reminder 高地址的 chunk 信息</span></span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 进一步检查后返回 chunk</span></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line">          <span class="comment">// 把取出的 chunk 分配到合适的 bin 里</span></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">				set_non_main_arena (victim);</span><br><span class="line">              </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line">            tcache_put (victim, tc_idx);</span><br><span class="line">            return_cached = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">              <span class="comment">/* place chunk in bin */</span></span><br><span class="line">              <span class="comment">//如果在 smallbin 的范围内</span></span><br><span class="line">              <span class="comment">//只用布置好 bck 和 fwd 然后跳到最后 victim 入链 </span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);		<span class="comment">// 计算得到 victim 将被放入的 bin 的 index</span></span><br><span class="line">              bck = bin_at (av, victim_index);			<span class="comment">// bck 为被放入的 bin 的链表头</span></span><br><span class="line">              fwd = bck-&gt;fd;						<span class="comment">// fwd 为最近加入 smallbin 的 chunk 头</span></span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//如果属于 largebin 的话还要布置好 size 相关指针</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);		<span class="comment">// 计算得到 victim 将被放入的 bin 的 index</span></span><br><span class="line">              bck = bin_at (av, victim_index);			<span class="comment">// bck 为被放入的 bin 的链表头</span></span><br><span class="line">              fwd = bck-&gt;fd;						<span class="comment">// fwd 为该链表中最大的 chunk</span></span><br><span class="line">				</span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="comment">//该链表不为空</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  </span><br><span class="line">                  <span class="comment">//bck-&gt;bk 是该链表中最小的 chunk ，如果 victim 比它还小</span></span><br><span class="line">                  <span class="comment">//则将它更改为最小的 chunk</span></span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;				<span class="comment">//此时 fwd 为链表头</span></span><br><span class="line">                      bck = bck-&gt;bk;			<span class="comment">//此时 bck 为最小的 chunk</span></span><br><span class="line">						</span><br><span class="line">                      <span class="comment">//既然 victim 要成为最小的 chunk ，那么它的 fd_nextsize 指针应该指向最大的 chunk</span></span><br><span class="line">                      <span class="comment">//也就是此时的 fwd-&gt;fd</span></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">//那么 bk_nextsize 就指向原来最小的 chunk</span></span><br><span class="line">                      <span class="comment">//链表中最大的 chunk 的 bk_nextsize 指向链表中最小的那个 chunk</span></span><br><span class="line">                      <span class="comment">//那么就是 fwd-&gt;fd-&gt;bk_nextsize</span></span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">//这里把最大 chunk 的 bk_nextsize 改成我们的 victim</span></span><br><span class="line">                      <span class="comment">//把原本最小 chunk 的 fd_nextsize 改成我们的 victim</span></span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">//在 largebin 的同一个序列中的 chunk 顺着 fd_nextsize 的方向 size 变小</span></span><br><span class="line">                      <span class="comment">//这个循环的意思是找到一个比当前 fwd 指的 chunk 要大的地址，存入 fwd 中。</span></span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line">                      </span><br><span class="line">                      <span class="comment">//如果找到了个和 victim 大小相同的 chunk，那就直接安排</span></span><br><span class="line">                      <span class="comment">//安排好 fwd 和 bck 后快进到 victim 入链</span></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">		  bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<h3 id="关键代码-2">关键代码</h3>
<h4 id="方法一">方法一</h4>
<p>​	Unsortedbin 中存放一个 size 较大的 chunk (CHUNK)，Largebin 里面放一个 size 较小的 chunk (victim)，这样就可以进入下面的循环。</p>
<p>​	其中，我们提前布置好 CHUNK 里面的 bk_nextsize 为 target_addr <strong>-0x20</strong> ，则 target_addr 位置将被修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">  &#123;</span><br><span class="line">    fwd = bck;				<span class="comment">//此时 fwd 为链表头</span></span><br><span class="line">    bck = bck-&gt;bk;			<span class="comment">//此时 bck 为 CHUNK</span></span><br><span class="line">						</span><br><span class="line">    <span class="comment">//此时的 fwd-&gt;fd 指向 CHUNK</span></span><br><span class="line">    </span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//CHUNK 的 bk_nextsize = target_addr - 0x20</span></span><br><span class="line">    </span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//victim-&gt;bk_nextsize-&gt;fd_nextsize = victim 会将</span></span><br><span class="line">    <span class="comment">//CHUNK 的 bk_nextsize + 0x20 处的值修改乘 victim</span></span><br><span class="line">    </span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二（-libc-2-30）">方法二（&lt; libc 2.30）</h4>
<p>​	Unsortedbin 里面放一个 size 较小的 chunk (下面的 fwd-&gt;fd), Largebin 中存放一个 size 较大的 chunk (下面的 victim )，这样就可以进入下面的循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 </span><br><span class="line">                 victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                 </span><br><span class="line">           <span class="comment">/* 这里我们提前布置好了 fwd-&gt;bk_nextsize = target_addr_1 -0x20 */</span></span><br><span class="line">                 </span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;bk_nextsize = victim;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* 所以 target_addr_1 处的值会被修改成 victim (一个很大的数) */</span></span><br><span class="line">                 </span><br><span class="line">                 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">             </span><br><span class="line">           <span class="comment">/* 这里我们提前布置好了 fwd-&gt;bk = target_addr_2 -0x10 */</span></span><br><span class="line">             </span><br><span class="line">             bck = fwd-&gt;bk;</span><br><span class="line">           &#125;</span><br><span class="line">       </span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> mark_bin (av, victim_index);</span><br><span class="line"> victim-&gt;bk = bck;</span><br><span class="line"> victim-&gt;fd = fwd;</span><br><span class="line"> fwd-&gt;bk = victim;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 所以 target_addr_2 处的值会被修改成 victim (一个很大的数)</span></span><br><span class="line"></span><br><span class="line"> bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<h3 id="检查代码-2">检查代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">      fwd = fwd-&gt;fd;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            victim-&gt;fd_nextsize = fwd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                 malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                 fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">             bck = fwd-&gt;bk;</span><br><span class="line">             <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">               malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> mark_bin (av, victim_index);</span><br><span class="line"> victim-&gt;bk = bck;</span><br><span class="line"> victim-&gt;fd = fwd;</span><br><span class="line"> fwd-&gt;bk = victim;</span><br><span class="line"> bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>检查代码使方法二难以利用，但方法一仍是可行的。</p>
<h3 id="参考资料-3">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://eur1ka.github.io/9434.html">unsortedbin-largebin攻击 - eur1ka’s blog</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/183877">ptmalloc利用之largebin attack - raycp</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5177">浅析largebin attack - Sr0cky</a></p>
<hr>
<h2 id="Unsafe-Unlink">Unsafe Unlink</h2>
<p><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/posts/unlink_smallbin_intro.png" alt=""></p>
<h3 id="条件">条件</h3>
<ol>
<li>UAF ，可修改 free 状态下 smallbin 或是 unsortedbin 的 fd 和 bk 指针</li>
<li>已知位置存在一个指针指向可进行 UAF 的 chunk</li>
</ol>
<h3 id="效果-2">效果</h3>
<p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p>
<h3 id="相关源码-libc-2-35">相关源码(libc 2.35)</h3>
<p>值得说明的是，高版本的 unlink 被实现成了函数，而低版本的则是宏(#define unlink(AV, P, BK, FD))。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list.  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 1.被 unlink 的 chunk 大小要和下一个 chunk 的 prev_size 相同</span></span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line">  <span class="comment">// 2.对 fd 和 bk 的检查</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="comment">// 3.不属于 smallbin 的话，还要进行额外的工作</span></span><br><span class="line">  <span class="comment">// smallbin 中的 chunk 的 fdnextsize 和 bknextsize 是没有意义的</span></span><br><span class="line">  <span class="comment">// 即使是 largebin，也只有在相同尺寸的同一组 chunks 中的第一个 chunk 中 fdnextsize 以及 bknextsize 才有意义</span></span><br><span class="line">  <span class="comment">// p-&gt;fd_nextsize != NULL 说明 P 是 尺寸相同的一组 chunks的第一个 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">          || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;fd_nextsize == p)</span><br><span class="line">            fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">              fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">              p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">              p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">          p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键代码-3">关键代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr fd = p-&gt;fd;</span><br><span class="line">mchunkptr bk = p-&gt;bk;</span><br><span class="line">fd-&gt;bk = bk;</span><br><span class="line">bk-&gt;fd = fd;</span><br></pre></td></tr></table></figure>
<p>​	我们先不管上面标注 1 2 3 的检查代码段。</p>
<p>​	这俩小段代码可以修改 p-&gt;fd 指向地址的 <strong>+ 0x18</strong> (p-&gt;fd指向地址的bk) 的内容为 p-&gt;bk ，p-&gt;bk 指向地址的 <strong>+ 0x10</strong> (p-&gt;bk指向地址的 fd) 内容为 p-&gt;fd 。</p>
<p>​	其实很好理解，如果是正常的链表进行 unlink ，就是将 p 拿出来，p 前面块的 bk 指向 p 的 bk，p 后面块的 fd 指向 p 的 fd。这样在拿出了 p 后，链表才能保持完整。</p>
<p>​	但如果我们通过某种方式达到了任意控制 p 的 fd 与 bk 指针的效果，那么我们就可以在 p-&gt;fd 指向地址的 <strong>+ 0x18</strong> 处写上 bk ，也就达到了任意写的效果，那岂不是简简单单就把一个程序给 <span class="emoji" alias="sheep" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f411.png?v8">🐑</span> 了。</p>
<p><em>PS：指向地址？</em></p>
<p>​	下图是一个被 free 掉进入 unsorted bin 后的图示，那么本文中我们约定此处 p-&gt;fd 的指向地址是在说 0x00000000006a0090 而不是 0x6a01c0 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+────────────+─────────────────────+──────────────────────+</span><br><span class="line">| <span class="number">0x6a01b0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000091</span>   |&lt;----|p_addr|prev_size|size|</span><br><span class="line">+────────────+─────────────────────+──────────────────────+</span><br><span class="line">| <span class="number">0x6a01c0</span>:  | <span class="number">0x00000000006a0090</span>  | <span class="number">0x00007f63cea65b78</span>   |&lt;----|p_addr+<span class="number">0x10</span>|p-&gt;fd|p-&gt;bk|</span><br><span class="line">| <span class="number">0x6a01d0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">+────────────+─────────────────────+──────────────────────+</span><br></pre></td></tr></table></figure>
<h3 id="绕过检查">绕过检查</h3>
<p>为了绕过上述的检查，Unlink 攻击失去了一开始任意写的能力，但仍有一定作用。</p>
<ol>
<li>
<p>这个很好解决，只要我们构造 chunk 的时候注意点就好。</p>
</li>
<li>
<p>这个非常致命，要求我们使 <strong>fd-&gt;bk == p &amp;&amp; bk-&gt;fd == p</strong></p>
</li>
</ol>
<p>那么为了顺利的搞事情，我们就要使 p-&gt;fd 指向地址的 <strong>+ 0x18</strong> 的内容为指向 p 的地址 ，p-&gt;bk 指向地址的 <strong>+ 0x10</strong> (p-&gt;bk指向地址的 fd) 内容为指向 p 的地址。</p>
<p>那么假设我们这里有一个指向 p 这个 chunk 的 chunk 头地址的指针 <strong>Ptr</strong> (这里假设 chunk 头地址为 0x6a01b0, chunk 指针地址为<strong>0x602100</strong>)</p>
<p>我们就要在 p-&gt;fd 处写上 <strong>Ptr - 0x18</strong> ，p-&gt;bk 处写上 <strong>Ptr - 0x10</strong> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+────────────+─────────────────────+──────────────────────+</span><br><span class="line">| <span class="number">0x6020e0</span>:  | <span class="number">0x00000000006a0010</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">| <span class="number">0x6020f0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">| <span class="number">0x602100</span>:  | <span class="number">0x00000000006a01b0</span>  | <span class="number">0x0000000000000088</span>   |&lt;---- Ptr <span class="number">0x602100</span></span><br><span class="line">+────────────+─────────────────────+──────────────────────+</span><br></pre></td></tr></table></figure>
<p>这样我们就可以如下构造 chunk p：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+────────────+─────────────────────+──────────────────────+</span><br><span class="line">| <span class="number">0x6a01b0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000091</span>   | &lt;----|p_addr|prev_size|size|</span><br><span class="line">+────────────+─────────────────────+──────────────────────+</span><br><span class="line">| <span class="number">0x6a01c0</span>:  | <span class="number">0x00000000006a20e8</span>  | <span class="number">0x00000000006020f0</span>   | &lt;----|p_addr+<span class="number">0x10</span>|p-&gt;fd|p-&gt;bk|</span><br><span class="line">| <span class="number">0x6a01d0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">| <span class="number">0x6a01e0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">+────────────+─────────────────────+──────────────────────+</span><br></pre></td></tr></table></figure>
<p>这里的 p-&gt;fd = 0x6020e8 = 0x602100 - 0x18 ，那么 p-&gt;fd <strong>+0x18</strong> 的地方恰好是存放 p 这个 chunk 的指针，那么就完成了绕过，bk 同理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mchunkptr fd = p-&gt;fd; <span class="comment">//fd = 0x6a20e8 Ptr-0x18</span></span><br><span class="line">mchunkptr bk = p-&gt;bk; <span class="comment">//bk = 0x6020f0 Ptr-0x10</span></span><br><span class="line">fd-&gt;bk = bk;	<span class="comment">// Ptr = Ptr - 0x10</span></span><br><span class="line">bk-&gt;fd = fd;	<span class="comment">// Ptr = Ptr - 0x18</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.</span> Before:</span><br><span class="line">   +────────────+─────────────────────+──────────────────────+</span><br><span class="line">   | <span class="number">0x6020e0</span>:  | <span class="number">0x00000000006a0010</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">   | <span class="number">0x6020f0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">   | <span class="number">0x602100</span>:  | <span class="number">0x00000000006a01b0</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">   +────────────+─────────────────────+──────────────────────+</span><br><span class="line"><span class="number">1.</span> fd-&gt;bk = bk;			</span><br><span class="line">   +────────────+─────────────────────+──────────────────────+</span><br><span class="line">   | <span class="number">0x6020e0</span>:  | <span class="number">0x00000000006a0010</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">   | <span class="number">0x6020f0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">   | <span class="number">0x602100</span>:  | <span class="number">0x00000000006020f0</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">   +────────────+─────────────────────+──────────────────────+</span><br><span class="line"><span class="number">2.</span> bk-&gt;fd = fd;</span><br><span class="line">   +────────────+─────────────────────+──────────────────────+</span><br><span class="line">   | <span class="number">0x6020e0</span>:  | <span class="number">0x00000000006a0010</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">   | <span class="number">0x6020f0</span>:  | <span class="number">0x0000000000000000</span>  | <span class="number">0x0000000000000000</span>   |</span><br><span class="line">   | <span class="number">0x602100</span>:  | <span class="number">0x00000000006a20e8</span>  | <span class="number">0x0000000000000088</span>   |</span><br><span class="line">   +────────────+─────────────────────+──────────────────────+</span><br></pre></td></tr></table></figure>
<p>那么我们就达到了 <strong>“使得已指向 UAF chunk 的指针 Ptr 变为 Ptr - 0x18”</strong> 这一最终效果。</p>
<h3 id="参考资料-4">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/">Unlink - CTF Wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1557872">一道题彻底理解 Pwn Heap Unlink</a></p>
<hr>
<h2 id="Tcache-Stashing-Unlink-Attack">Tcache Stashing Unlink Attack</h2>
<h3 id="条件-2">条件</h3>
<ol>
<li>存在俩 smallbin chunk 且对应大小 tcache 放了 5 个 chunk。意思是塞入俩 chunk 后对应大小 Tcache 就满了。(用最后给出的构造方法或河里利用 calloc等)</li>
<li>UAF ，可修改 free 状态下 smallbin 的 bk 指针</li>
<li>已知位置存在一个指针指向可进行 UAF 的 chunk</li>
</ol>
<h3 id="效果-3">效果</h3>
<ol>
<li>往指向 UAF chunk 的指针 ptr 写 main_arena 来泄露 libc</li>
<li>分配 chunk 到 ptr</li>
</ol>
<h3 id="相关代码-4">相关代码</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br><span class="line">... </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="comment">/*************************************************************************************/</span></span><br><span class="line">+───────────────────+──────────+────────────+─────+──────────+──────────+</span><br><span class="line">| bin_at (av, idx)  | chunk n  | chunk n<span class="number">-1</span>  | ……  | chunk <span class="number">2</span>  | chunk <span class="number">1</span>  |</span><br><span class="line">+───────────────────+──────────+────────────+─────+──────────+──────────+</span><br><span class="line">| bin               |          |            |     | bck      | victim   |</span><br><span class="line">+───────────────────+──────────+────────────+─────+──────────+──────────+</span><br><span class="line">    		fd</span><br><span class="line">	-------------------&gt;</span><br><span class="line"><span class="comment">/*************************************************************************************/</span> </span><br><span class="line">    <span class="comment">// 如果属于 smallbin 的范围</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取 size 大小对应的下标</span></span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      <span class="comment">// 获取下标对应的 smallbin 链表头</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="comment">// victim 取链表的最后一个 chunk ，victim 不是链表头，说明不为空</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// bck 为 倒数第二个 chunk</span></span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="comment">// 完整性检查</span></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 将返回 victim 作为本次 malloc 返回的 chunk */</span></span><br><span class="line">          <span class="comment">// 给相邻的高地址 chunk 设置 prev_inuse 位说明 victim 处于 use 状态</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/* 把 victim 从链表取出 */</span></span><br><span class="line">          <span class="comment">// 记录的最后一个 chunk 的 bin-&gt;bk 指向倒数第二个</span></span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          <span class="comment">// 倒数第二个 chunk 变为倒数第一个后 fd 指向 链表头 bin</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="comment">/*************************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">          <span class="comment">// 由 malloc 请求的 size 计算 tcache 下标</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">          <span class="comment">// tcache 存在且下标存在</span></span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">          <span class="comment">/* 当 smallbin 不为空且 tcache 塞得下，把原本 smallbin 链表中的 chunk 往 tcache 里面塞 */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">              <span class="comment">// bck 为 倒数第二个 chunk</span></span><br><span class="line">              <span class="comment">/* 很明显这里没有了完整性检查 */</span></span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">              <span class="comment">// 给相邻的高地址 chunk 设置 prev_inuse 位</span></span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">              </span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">              <span class="comment">/* 把 victim 从链表取出 */</span></span><br><span class="line">              <span class="comment">// 记录的最后一个 chunk 的 bin-&gt;bk 指向倒数第二个</span></span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">              <span class="comment">// 倒数第二个 chunk 变为倒数第一个后 fd 指向 链表头 bin</span></span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//把原本 smallbin 链表中的 chunk 往 tcache 里面塞</span></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="comment">// p 转换为不含 chunk 头的指针</span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键代码-4">关键代码</h3>
<ol>
<li>往指向 UAF chunk 的指针 ptr 写 main_arena 来泄露 libc</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 通过 UAF 写 bk 指向 ptr - 0x10 绕过检查</span></span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// bin 的 bk 被改写为 ptr - 0x10</span></span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        <span class="comment">// ptr 被写成 main_arena</span></span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>分配 chunk 到 ptr 上方</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 值得注意的是 last(bin) 是指 bin-&gt;bk</span></span><br><span class="line">     <span class="comment">// 但是 bin-&gt;bk 已经被我们不知道扬到哪里去了，所以要保证 Tcache 里面</span></span><br><span class="line">     <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// victim 取的是我们上面改写的 ptr - 0x10</span></span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line">            </span><br><span class="line">     <span class="comment">// 把 ptr - 0x10 处 chunk 放入了 tcache</span></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            </span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意-3">注意</h3>
<p>Smallbin 中相邻的俩 free chunk 会合并，构造时需要避免这种情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we malloc 9 chunks</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//put 7 tcache</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then we free 7 of them in order to put them into tcache. Carefully we didn&#x27;t free a serial of chunks like chunk2 to chunk9, because an unsorted bin next to another will be merged into one after another malloc.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As you can see, chunk1 &amp; [chunk3,chunk8] are put into tcache bins while chunk0 and chunk2 will be put into unsorted bin.\n\n&quot;</span>);</span><br><span class="line"><span class="comment">//last tcache bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//now they are put into unsorted bin</span></span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//convert into small bin</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we alloc a chunk larger than 0x90 to put chunk0 and chunk2 into small bin.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//now 5 tcache bins</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then we malloc two chunks to spare space for small bins. After that, we now have 5 tcache bins and 2 small bins\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br></pre></td></tr></table></figure>
<h3 id="参考资料-5">参考资料</h3>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/#tcache-stashing-unlink-attack">Tcache attack - CTF Wiki</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">uuu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://caffelne.github.io/posts/53983.html">http://caffelne.github.io/posts/53983.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://caffelne.github.io" target="_blank">uuu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a></div><div class="post_share"><div class="social-share" data-image="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/pwn_1@Lifeline.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/21b97b6b.html"><img class="prev-cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/pwn_2@Lifeline.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Pwn 刷题笔记</div></div></a></div><div class="next-post pull-right"><a href="/posts/1976.html"><img class="next-cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/BASE1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">俩道 Base 题目</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c65a48dc.html" title="【Game.04】2021 羊城杯 Pwn 复现"><img class="cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/2021_ycb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-07</div><div class="title">【Game.04】2021 羊城杯 Pwn 复现</div></div></a></div><div><a href="/posts/fe829aea.html" title="【Game.01】Wolvsec2022 Pwn WriteUp"><img class="cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Wolvsec.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-28</div><div class="title">【Game.01】Wolvsec2022 Pwn WriteUp</div></div></a></div><div><a href="/posts/5ae36485.html" title="【Heap.03】House of 系列学习"><img class="cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/1140961.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-23</div><div class="title">【Heap.03】House of 系列学习</div></div></a></div><div><a href="/posts/d6d32804.html" title="【Heap.05】Glibc 2.32 以上的指针异或加密机制详解以及俩道例题"><img class="cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/wallhaven-76dg8y.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-03</div><div class="title">【Heap.05】Glibc 2.32 以上的指针异或加密机制详解以及俩道例题</div></div></a></div><div><a href="/posts/21b97b6b.html" title="Pwn 刷题笔记"><img class="cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Cover/pwn_2@Lifeline.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-12</div><div class="title">Pwn 刷题笔记</div></div></a></div><div><a href="/posts/87eea22c.html" title="【Heap.02】在出题人保护全开的围堵下抓住一线生机"><img class="cover" src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/1140962.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-21</div><div class="title">【Heap.02】在出题人保护全开的围堵下抓住一线生机</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/Avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">uuu</div><div class="author-info__description">路还长 梦还多</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/caffelne"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/caffelne" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Off-by-one"><span class="toc-number">1.1.</span> <span class="toc-text">Off by one</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.1.2.</span> <span class="toc-text">常见漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">相关题目记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk-Extend-and-Overlapping"><span class="toc-number">1.2.</span> <span class="toc-text">Chunk Extend and Overlapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">1.2.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%A4%BA%E4%BE%8B-libc-2-23%E4%B8%8B-%EF%BC%8Clibc-2-27-%E5%88%99%E5%85%88%E5%A4%84%E7%90%86-Tcache"><span class="toc-number">1.2.4.</span> <span class="toc-text">利用示例(libc 2.23下 ，libc 2.27 则先处理 Tcache)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.5.</span> <span class="toc-text">相关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink-%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.6.</span> <span class="toc-text">unlink 绕过原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-2-29-%E6%A3%80%E6%B5%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.7.</span> <span class="toc-text">libc 2.29 检测代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.2.8.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsortedbin-Attack-libc-2-28"><span class="toc-number">1.3.</span> <span class="toc-text">Unsortedbin Attack(&lt; libc 2.28)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9D%A5%E6%BA%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">基本使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.3.4.</span> <span class="toc-text">相关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.5.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.6.</span> <span class="toc-text">检查代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-2"><span class="toc-number">1.3.7.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Largebin-Attack"><span class="toc-number">1.4.</span> <span class="toc-text">Largebin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.4.1.</span> <span class="toc-text">相关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">关键代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%88-libc-2-30%EF%BC%89"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">方法二（&lt; libc 2.30）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">检查代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-3"><span class="toc-number">1.4.4.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe-Unlink"><span class="toc-number">1.5.</span> <span class="toc-text">Unsafe Unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.1.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-2"><span class="toc-number">1.5.2.</span> <span class="toc-text">效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81-libc-2-35"><span class="toc-number">1.5.3.</span> <span class="toc-text">相关源码(libc 2.35)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.5.4.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E6%A3%80%E6%9F%A5"><span class="toc-number">1.5.5.</span> <span class="toc-text">绕过检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-4"><span class="toc-number">1.5.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tcache-Stashing-Unlink-Attack"><span class="toc-number">1.6.</span> <span class="toc-text">Tcache Stashing Unlink Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6-2"><span class="toc-number">1.6.1.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-3"><span class="toc-number">1.6.2.</span> <span class="toc-text">效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.6.3.</span> <span class="toc-text">相关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.6.4.</span> <span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="toc-number">1.6.5.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-5"><span class="toc-number">1.6.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c07eff46.html" title="【Game.06】2022 DASCTF MAY 出题人挑战赛 Writeup"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/image-20220523123857608.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Game.06】2022 DASCTF MAY 出题人挑战赛 Writeup"/></a><div class="content"><a class="title" href="/posts/c07eff46.html" title="【Game.06】2022 DASCTF MAY 出题人挑战赛 Writeup">【Game.06】2022 DASCTF MAY 出题人挑战赛 Writeup</a><time datetime="2022-05-23T04:31:49.000Z" title="发表于 2022-05-23 12:31:49">2022-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/13285c73.html" title="【EP.02】_IO_FILE 艺术鉴赏"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/wallhaven-y8ogmx.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【EP.02】_IO_FILE 艺术鉴赏"/></a><div class="content"><a class="title" href="/posts/13285c73.html" title="【EP.02】_IO_FILE 艺术鉴赏">【EP.02】_IO_FILE 艺术鉴赏</a><time datetime="2022-05-18T08:41:00.000Z" title="发表于 2022-05-18 16:41:00">2022-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/ab2b6a2b.html" title="【EP.01】shellcode 艺术鉴赏"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/91458.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【EP.01】shellcode 艺术鉴赏"/></a><div class="content"><a class="title" href="/posts/ab2b6a2b.html" title="【EP.01】shellcode 艺术鉴赏">【EP.01】shellcode 艺术鉴赏</a><time datetime="2022-05-06T13:11:49.000Z" title="发表于 2022-05-06 21:11:49">2022-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d6d32804.html" title="【Heap.05】Glibc 2.32 以上的指针异或加密机制详解以及俩道例题"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/wallhaven-76dg8y.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Heap.05】Glibc 2.32 以上的指针异或加密机制详解以及俩道例题"/></a><div class="content"><a class="title" href="/posts/d6d32804.html" title="【Heap.05】Glibc 2.32 以上的指针异或加密机制详解以及俩道例题">【Heap.05】Glibc 2.32 以上的指针异或加密机制详解以及俩道例题</a><time datetime="2022-05-03T15:01:40.000Z" title="发表于 2022-05-03 23:01:40">2022-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d80f8624.html" title="【Game.05】2022 中国海洋大学校赛 Writeup"><img src="https://blog-1310088624.cos.ap-nanjing.myqcloud.com/blog/image-20220502142421555.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Game.05】2022 中国海洋大学校赛 Writeup"/></a><div class="content"><a class="title" href="/posts/d80f8624.html" title="【Game.05】2022 中国海洋大学校赛 Writeup">【Game.05】2022 中国海洋大学校赛 Writeup</a><time datetime="2022-05-02T13:05:03.000Z" title="发表于 2022-05-02 21:05:03">2022-05-02</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2022 By uuu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">被这话 / 欺骗的 / 何止你我</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'f8c1aa5156a51043b92c',
      clientSecret: '2dbd19fe6377d79a5f1af0d87db7c177c1e51c49',
      repo: 'caffelne.github.io',
      owner: 'caffelne',
      admin: ['caffelne'],
      id: '37527fa715ad798e9b081b0fe322aede',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>